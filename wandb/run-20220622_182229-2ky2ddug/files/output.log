train.py:11: DeprecationWarning: fractions.gcd() is deprecated. Use math.gcd() instead.
  def lcm(a,b): return abs(a * b)/fractions.gcd(a,b) if a and b else 0
dataset [AlignedDataset] was created
CustomDatasetDataLoader
#training images = 22602
ALIASGenerator(
  (conv_0): Conv2d(9, 1024, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
  (conv_1): Conv2d(9, 16, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
  (conv_2): Conv2d(9, 16, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
  (conv_3): Conv2d(9, 16, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
  (conv_4): Conv2d(9, 16, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
  (conv_5): Conv2d(9, 16, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
  (conv_6): Conv2d(9, 16, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
  (conv_7): Conv2d(9, 16, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
  (head_0): ALIASResBlock(
    (conv_0): Conv2d(1024, 1024, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (conv_1): Conv2d(1024, 1024, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (norm_0): ALIASNorm(
      (param_free_norm): MaskNorm(
        (norm_layer): InstanceNorm2d(1024, eps=1e-05, momentum=0.1, affine=False, track_running_stats=False)
      )
      (conv_shared): Sequential(
        (0): Conv2d(8, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
        (1): ReLU()
      )
      (conv_gamma): Conv2d(128, 1024, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
      (conv_beta): Conv2d(128, 1024, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    )
    (norm_1): ALIASNorm(
      (param_free_norm): MaskNorm(
        (norm_layer): InstanceNorm2d(1024, eps=1e-05, momentum=0.1, affine=False, track_running_stats=False)
      )
      (conv_shared): Sequential(
        (0): Conv2d(8, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
        (1): ReLU()
      )
      (conv_gamma): Conv2d(128, 1024, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
      (conv_beta): Conv2d(128, 1024, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    )
    (relu): LeakyReLU(negative_slope=0.2)
  )
  (G_middle_0): ALIASResBlock(
    (conv_0): Conv2d(1040, 1024, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (conv_1): Conv2d(1024, 1024, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (conv_s): Conv2d(1040, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)
    (norm_0): ALIASNorm(
      (param_free_norm): MaskNorm(
        (norm_layer): InstanceNorm2d(1040, eps=1e-05, momentum=0.1, affine=False, track_running_stats=False)
      )
      (conv_shared): Sequential(
        (0): Conv2d(8, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
        (1): ReLU()
      )
      (conv_gamma): Conv2d(128, 1040, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
      (conv_beta): Conv2d(128, 1040, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    )
    (norm_1): ALIASNorm(
      (param_free_norm): MaskNorm(
        (norm_layer): InstanceNorm2d(1024, eps=1e-05, momentum=0.1, affine=False, track_running_stats=False)
      )
      (conv_shared): Sequential(
        (0): Conv2d(8, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
        (1): ReLU()
      )
      (conv_gamma): Conv2d(128, 1024, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
      (conv_beta): Conv2d(128, 1024, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    )
    (norm_s): ALIASNorm(
      (param_free_norm): MaskNorm(
        (norm_layer): InstanceNorm2d(1040, eps=1e-05, momentum=0.1, affine=False, track_running_stats=False)
      )
      (conv_shared): Sequential(
        (0): Conv2d(8, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
        (1): ReLU()
      )
      (conv_gamma): Conv2d(128, 1040, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
      (conv_beta): Conv2d(128, 1040, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    )
    (relu): LeakyReLU(negative_slope=0.2)
  )
  (G_middle_1): ALIASResBlock(
    (conv_0): Conv2d(1040, 1024, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (conv_1): Conv2d(1024, 1024, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (conv_s): Conv2d(1040, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)
    (norm_0): ALIASNorm(
      (param_free_norm): MaskNorm(
        (norm_layer): InstanceNorm2d(1040, eps=1e-05, momentum=0.1, affine=False, track_running_stats=False)
      )
      (conv_shared): Sequential(
        (0): Conv2d(8, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
        (1): ReLU()
      )
      (conv_gamma): Conv2d(128, 1040, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
      (conv_beta): Conv2d(128, 1040, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    )
    (norm_1): ALIASNorm(
      (param_free_norm): MaskNorm(
        (norm_layer): InstanceNorm2d(1024, eps=1e-05, momentum=0.1, affine=False, track_running_stats=False)
      )
      (conv_shared): Sequential(
        (0): Conv2d(8, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
        (1): ReLU()
      )
      (conv_gamma): Conv2d(128, 1024, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
      (conv_beta): Conv2d(128, 1024, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    )
    (norm_s): ALIASNorm(
      (param_free_norm): MaskNorm(
        (norm_layer): InstanceNorm2d(1040, eps=1e-05, momentum=0.1, affine=False, track_running_stats=False)
      )
      (conv_shared): Sequential(
        (0): Conv2d(8, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
        (1): ReLU()
      )
      (conv_gamma): Conv2d(128, 1040, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
      (conv_beta): Conv2d(128, 1040, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    )
    (relu): LeakyReLU(negative_slope=0.2)
  )
  (up_0): ALIASResBlock(
    (conv_0): Conv2d(1040, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (conv_1): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (conv_s): Conv2d(1040, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)
    (norm_0): ALIASNorm(
      (param_free_norm): MaskNorm(
        (norm_layer): InstanceNorm2d(1040, eps=1e-05, momentum=0.1, affine=False, track_running_stats=False)
      )
      (conv_shared): Sequential(
        (0): Conv2d(8, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
        (1): ReLU()
      )
      (conv_gamma): Conv2d(128, 1040, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
      (conv_beta): Conv2d(128, 1040, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    )
    (norm_1): ALIASNorm(
      (param_free_norm): MaskNorm(
        (norm_layer): InstanceNorm2d(512, eps=1e-05, momentum=0.1, affine=False, track_running_stats=False)
      )
      (conv_shared): Sequential(
        (0): Conv2d(8, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
        (1): ReLU()
      )
      (conv_gamma): Conv2d(128, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
      (conv_beta): Conv2d(128, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    )
    (norm_s): ALIASNorm(
      (param_free_norm): MaskNorm(
        (norm_layer): InstanceNorm2d(1040, eps=1e-05, momentum=0.1, affine=False, track_running_stats=False)
      )
      (conv_shared): Sequential(
        (0): Conv2d(8, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
        (1): ReLU()
      )
      (conv_gamma): Conv2d(128, 1040, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
      (conv_beta): Conv2d(128, 1040, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    )
    (relu): LeakyReLU(negative_slope=0.2)
  )
  (up_1): ALIASResBlock(
    (conv_0): Conv2d(528, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (conv_1): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (conv_s): Conv2d(528, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)
    (norm_0): ALIASNorm(
      (param_free_norm): MaskNorm(
        (norm_layer): InstanceNorm2d(528, eps=1e-05, momentum=0.1, affine=False, track_running_stats=False)
      )
      (conv_shared): Sequential(
        (0): Conv2d(8, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
        (1): ReLU()
      )
      (conv_gamma): Conv2d(128, 528, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
      (conv_beta): Conv2d(128, 528, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    )
    (norm_1): ALIASNorm(
      (param_free_norm): MaskNorm(
        (norm_layer): InstanceNorm2d(256, eps=1e-05, momentum=0.1, affine=False, track_running_stats=False)
      )
      (conv_shared): Sequential(
        (0): Conv2d(8, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
        (1): ReLU()
      )
      (conv_gamma): Conv2d(128, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
      (conv_beta): Conv2d(128, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    )
    (norm_s): ALIASNorm(
      (param_free_norm): MaskNorm(
        (norm_layer): InstanceNorm2d(528, eps=1e-05, momentum=0.1, affine=False, track_running_stats=False)
      )
      (conv_shared): Sequential(
        (0): Conv2d(8, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
        (1): ReLU()
      )
      (conv_gamma): Conv2d(128, 528, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
      (conv_beta): Conv2d(128, 528, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    )
    (relu): LeakyReLU(negative_slope=0.2)
  )
  (up_2): ALIASResBlock(
    (conv_0): Conv2d(272, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (conv_1): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (conv_s): Conv2d(272, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
    (norm_0): ALIASNorm(
      (param_free_norm): InstanceNorm2d(272, eps=1e-05, momentum=0.1, affine=False, track_running_stats=False)
      (conv_shared): Sequential(
        (0): Conv2d(7, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
        (1): ReLU()
      )
      (conv_gamma): Conv2d(128, 272, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
      (conv_beta): Conv2d(128, 272, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    )
    (norm_1): ALIASNorm(
      (param_free_norm): InstanceNorm2d(128, eps=1e-05, momentum=0.1, affine=False, track_running_stats=False)
      (conv_shared): Sequential(
        (0): Conv2d(7, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
        (1): ReLU()
      )
      (conv_gamma): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
      (conv_beta): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    )
    (norm_s): ALIASNorm(
      (param_free_norm): InstanceNorm2d(272, eps=1e-05, momentum=0.1, affine=False, track_running_stats=False)
      (conv_shared): Sequential(
        (0): Conv2d(7, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
        (1): ReLU()
      )
      (conv_gamma): Conv2d(128, 272, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
      (conv_beta): Conv2d(128, 272, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    )
    (relu): LeakyReLU(negative_slope=0.2)
  )
  (up_3): ALIASResBlock(
    (conv_0): Conv2d(144, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (conv_1): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (conv_s): Conv2d(144, 64, kernel_size=(1, 1), stride=(1, 1), bias=False)
    (norm_0): ALIASNorm(
      (param_free_norm): InstanceNorm2d(144, eps=1e-05, momentum=0.1, affine=False, track_running_stats=False)
      (conv_shared): Sequential(
        (0): Conv2d(7, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
        (1): ReLU()
      )
      (conv_gamma): Conv2d(128, 144, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
      (conv_beta): Conv2d(128, 144, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    )
    (norm_1): ALIASNorm(
      (param_free_norm): InstanceNorm2d(64, eps=1e-05, momentum=0.1, affine=False, track_running_stats=False)
      (conv_shared): Sequential(
        (0): Conv2d(7, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
        (1): ReLU()
      )
      (conv_gamma): Conv2d(128, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
      (conv_beta): Conv2d(128, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    )
    (norm_s): ALIASNorm(
      (param_free_norm): InstanceNorm2d(144, eps=1e-05, momentum=0.1, affine=False, track_running_stats=False)
      (conv_shared): Sequential(
        (0): Conv2d(7, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
        (1): ReLU()
      )
      (conv_gamma): Conv2d(128, 144, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
      (conv_beta): Conv2d(128, 144, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    )
    (relu): LeakyReLU(negative_slope=0.2)
  )
  (up_4): ALIASResBlock(
    (conv_0): Conv2d(80, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (conv_1): Conv2d(32, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (conv_s): Conv2d(80, 32, kernel_size=(1, 1), stride=(1, 1), bias=False)
    (norm_0): ALIASNorm(
      (param_free_norm): InstanceNorm2d(80, eps=1e-05, momentum=0.1, affine=False, track_running_stats=False)
      (conv_shared): Sequential(
        (0): Conv2d(7, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
        (1): ReLU()
      )
      (conv_gamma): Conv2d(128, 80, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
      (conv_beta): Conv2d(128, 80, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    )
    (norm_1): ALIASNorm(
      (param_free_norm): InstanceNorm2d(32, eps=1e-05, momentum=0.1, affine=False, track_running_stats=False)
      (conv_shared): Sequential(
        (0): Conv2d(7, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
        (1): ReLU()
      )
      (conv_gamma): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
      (conv_beta): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    )
    (norm_s): ALIASNorm(
      (param_free_norm): InstanceNorm2d(80, eps=1e-05, momentum=0.1, affine=False, track_running_stats=False)
      (conv_shared): Sequential(
        (0): Conv2d(7, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
        (1): ReLU()
      )
      (conv_gamma): Conv2d(128, 80, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
      (conv_beta): Conv2d(128, 80, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    )
    (relu): LeakyReLU(negative_slope=0.2)
  )
  (conv_img): Conv2d(32, 3, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
  (up): Upsample(scale_factor=2.0, mode=nearest)
  (relu): LeakyReLU(negative_slope=0.2)
  (tanh): Tanh()
)
MultiscaleDiscriminator(
  (scale0_layer0): Sequential(
    (0): Conv2d(19, 64, kernel_size=(4, 4), stride=(2, 2), padding=(2, 2))
    (1): LeakyReLU(negative_slope=0.2, inplace=True)
  )
  (scale0_layer1): Sequential(
    (0): Conv2d(64, 128, kernel_size=(4, 4), stride=(2, 2), padding=(2, 2))
    (1): InstanceNorm2d(128, eps=1e-05, momentum=0.1, affine=False, track_running_stats=False)
    (2): LeakyReLU(negative_slope=0.2, inplace=True)
  )
  (scale0_layer2): Sequential(
    (0): Conv2d(128, 256, kernel_size=(4, 4), stride=(2, 2), padding=(2, 2))
    (1): InstanceNorm2d(256, eps=1e-05, momentum=0.1, affine=False, track_running_stats=False)
    (2): LeakyReLU(negative_slope=0.2, inplace=True)
  )
  (scale0_layer3): Sequential(
    (0): Conv2d(256, 512, kernel_size=(4, 4), stride=(1, 1), padding=(2, 2))
    (1): InstanceNorm2d(512, eps=1e-05, momentum=0.1, affine=False, track_running_stats=False)
    (2): LeakyReLU(negative_slope=0.2, inplace=True)
  )
  (scale0_layer4): Sequential(
    (0): Conv2d(512, 1, kernel_size=(4, 4), stride=(1, 1), padding=(2, 2))
  )
  (scale1_layer0): Sequential(
    (0): Conv2d(19, 64, kernel_size=(4, 4), stride=(2, 2), padding=(2, 2))
    (1): LeakyReLU(negative_slope=0.2, inplace=True)
  )
  (scale1_layer1): Sequential(
    (0): Conv2d(64, 128, kernel_size=(4, 4), stride=(2, 2), padding=(2, 2))
    (1): InstanceNorm2d(128, eps=1e-05, momentum=0.1, affine=False, track_running_stats=False)
    (2): LeakyReLU(negative_slope=0.2, inplace=True)
  )
  (scale1_layer2): Sequential(
    (0): Conv2d(128, 256, kernel_size=(4, 4), stride=(2, 2), padding=(2, 2))
    (1): InstanceNorm2d(256, eps=1e-05, momentum=0.1, affine=False, track_running_stats=False)
    (2): LeakyReLU(negative_slope=0.2, inplace=True)
  )
  (scale1_layer3): Sequential(
    (0): Conv2d(256, 512, kernel_size=(4, 4), stride=(1, 1), padding=(2, 2))
    (1): InstanceNorm2d(512, eps=1e-05, momentum=0.1, affine=False, track_running_stats=False)
    (2): LeakyReLU(negative_slope=0.2, inplace=True)
  )
  (scale1_layer4): Sequential(
    (0): Conv2d(512, 1, kernel_size=(4, 4), stride=(1, 1), padding=(2, 2))
  )
  (downsample): AvgPool2d(kernel_size=3, stride=2, padding=[1, 1])
)
  0%|                                                                                         | 0/11301 [00:00<?, ?it/s]
model [Pix2PixHDModel] was created
create web directory checkpoints/ALIAS_ETRI_TOP_pbafn_vis/web...
Ia:torch.Size([2, 3, 1024, 768]) dtype:  torch.float32 tensor(1.) tensor(-1.)
P:torch.Size([2, 3, 1024, 768]) dtype:  torch.float32 tensor(0.9451) tensor(-1.)
Wc:torch.Size([2, 3, 1024, 768]) dtype:  torch.float32 tensor(0.9950) tensor(-0.7869)
M_a:torch.Size([2, 1, 1024, 768]) dtype:  torch.float32 tensor(1.) tensor(0.)
S:torch.Size([2, 7, 1024, 768]) dtype:  torch.float32 tensor(1.) tensor(0.)
Sdiv:torch.Size([2, 8, 1024, 768]) dtype:  torch.float32 tensor(1.) tensor(0.)
Mdiv:torch.Size([2, 1, 1024, 768]) dtype:  torch.float32 tensor(1.) tensor(0.)
  0%|                                                                                         | 0/11301 [00:20<?, ?it/s]
Traceback (most recent call last):
  File "train.py", line 108, in <module>
    (losses, generated),vgg_loss_map,Feat_loss_map = model(Ia, P, Wc, S, Sdiv, Mdiv,Ma ,Igt, infer=save_fake)
  File "/home/ubuntu/anaconda3/lib/python3.8/site-packages/torch/nn/modules/module.py", line 1102, in _call_impl
    return forward_call(*input, **kwargs)
  File "/home/ubuntu/anaconda3/lib/python3.8/site-packages/torch/nn/parallel/data_parallel.py", line 158, in forward
    inputs, kwargs = self.scatter(inputs, kwargs, self.device_ids)
  File "/home/ubuntu/anaconda3/lib/python3.8/site-packages/torch/nn/parallel/data_parallel.py", line 175, in scatter
    return scatter_kwargs(inputs, kwargs, device_ids, dim=self.dim)
  File "/home/ubuntu/anaconda3/lib/python3.8/site-packages/torch/nn/parallel/scatter_gather.py", line 44, in scatter_kwargs
    inputs = scatter(inputs, target_gpus, dim) if inputs else []
  File "/home/ubuntu/anaconda3/lib/python3.8/site-packages/torch/nn/parallel/scatter_gather.py", line 36, in scatter
    res = scatter_map(inputs)
  File "/home/ubuntu/anaconda3/lib/python3.8/site-packages/torch/nn/parallel/scatter_gather.py", line 23, in scatter_map
    return list(zip(*map(scatter_map, obj)))
  File "/home/ubuntu/anaconda3/lib/python3.8/site-packages/torch/nn/parallel/scatter_gather.py", line 19, in scatter_map
    return Scatter.apply(target_gpus, None, dim, obj)
  File "/home/ubuntu/anaconda3/lib/python3.8/site-packages/torch/nn/parallel/_functions.py", line 95, in forward
    streams = [_get_stream(device) for device in target_gpus]
  File "/home/ubuntu/anaconda3/lib/python3.8/site-packages/torch/nn/parallel/_functions.py", line 95, in <listcomp>
    streams = [_get_stream(device) for device in target_gpus]
  File "/home/ubuntu/anaconda3/lib/python3.8/site-packages/torch/nn/parallel/_functions.py", line 123, in _get_stream
    _streams[device] = torch.cuda.Stream(device)
  File "/home/ubuntu/anaconda3/lib/python3.8/site-packages/torch/cuda/streams.py", line 33, in __new__
    return super(Stream, cls).__new__(cls, priority=priority, **kwargs)
RuntimeError: CUDA error: out of memory
CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.
For debugging consider passing CUDA_LAUNCH_BLOCKING=1.